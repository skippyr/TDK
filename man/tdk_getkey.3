.TH tdk_getkey 3 MANDATE tdk
.SH NAME
.PP
tdk_getkey - it reads and parses a blocking key press

.SH LIBRARY
.PP
tdk (libtdk, -ltdk)

.SH SYNOPSIS
.PP
#include <tdk.h>

.PP
int tdk_getkey(void);

.SH DESCRIPTION
.PP
It blocks the program execution until a key press is read and then parses it. It
has minimal support for modifier keys.

After a successful reading, it clears the input buffer.

.SH RETURN VALUES
.IP \[bu]
It returns WOEF if the key reading fails. That happens if: stdin is being
redirected or it is not wide-character oriented; and if stdout and stderr are
being redirected.

.IP \[bu]
It returns 0 if the key read could not be parsed.

.IP \[bu]
Otherwise, it returns a special key value or an UTF-8 character representing
the key.

.SH KEYS
These values can be used for checks against special keys and some UTF-8
characters:

.TP
.B
tdk_KeyUpArr, tdk_KeyDnArr, tdk_KeyRgArr, tdk_KeyLfArr
The arrow keys.

.TP
.B
tdk_KeyF1 - tdk_KeyF12
The function keys.

.TP
.B
tdk_KeyIns, tdk_KeyDel, tdk_Enter, tdk_BSpace
The insertion/deletion keys.

.TP
.B
tdk_KeyHome, tdk_KeyEnd, tdk_KeyPgUp, tdk_KeyPgDn, tdk_KeyEsc
The navigation keys.

.SH EXAMPLES
.PP
int key = tdk_getkey();
.br
if (key == tdk_KeyUpArr || key == 'k' || key == 'K')
.br
	printf("Up keybindings\\n");
.br
else if ((key >= 'a' && key <= 'z') || (key >= 'A' && key <= 'Z'))
.br
	printf("English Alphabet Range\\n");
.br
else if (key >= tdk_KeyF1 && key <= tdk_KeyF12)
.br
	printf("Function Keys Range\\n");
.br
else if (key == L'α' || key == L'あ' || key == L'ç')
.br
	printf("Foreign Language Keys\\n");
.br
else if (key == L'🔥' || key == L'🐉')
.br
	printf("Emojis\\n");

.SH NOTES
.PP
Terminals may define keybinds that blocks you from using some keys.

.SH SEE ALSO
.BR tdk (3)
