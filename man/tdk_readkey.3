.TH tdk_readkey 3 ${VERSION}

.SH NAME

.PP
tdk_readkey - it reads UTF-8 characters and parses terminal key presses

.SH LIBRARY

.PP
tdk (\fIlibtdk\fR, \fI-ltdk\fR)

.SH SYNOPSIS

.nf
\fB#include\fR <tdk.h>

\fBint\fR tdk_readkey(\fBint\fR *\fIkey\fR, \fBchar\fR *\fImod\fR);
.fi

.SH DESCRIPTION

.PP
It reads UTF-8 characters from the terminal input buffer and parses key presses. All information collected gets put into the addresses pointed by its parameters:

.IP \\[bu]
The \fIkey\fR parameter holds a number that identifies the key pressed. It may be an UTF-8 character or a key value defined by the library. It will be 0 if the key could not be identified.

.IP \\[bu]
The \fImod\fR parameter holds a bitmask that contains the modifier keys that were being hold during the key press. It will be 0 if nothing could be identified.

It is optional: if not required, its address may be set to NULL.

.PP
To allow the user to paste contents into the terminal, it does not clear the input buffer. If you need to clear it up, use tdk_clearin() (3).

.PP
Apart from all of that, it has some limitations to identify keys that you will see by reading further.

.SH RETURN VALUES

.PP
If its reading succeeds, it returns 0, and -1 otherwise. It fails if a proper interaction with the user can not happen, that is if the standard input stream or the standard output and error streams are being redirected.

.SH KEYS

.PP
These are key values defined by the library primarly to identify keys that are not represented by UTF-8 characters.

.PP
You will find out that some are actually UTF-8 characters, but whose value here can be used instead to improve readability:

.TP
.B TDK_KEYUPARR, TDK_KEYDNARR, TDK_KEYRGARR, TDK_KEYLFARR
These identify the arrow keys.

.TP
.B TDK_KEYINS, TDK_KEYDEL, TDK_KEYHOME, TDK_KEYEND, TDK_KEYPGUP, TDK_KEYPGDN
These identify the navigation keys.

.TP
.B TDK_KEYPRTSC, TDK_KEYPAUSE
These identify the system control keys.

.TP
.B TDK_KEYF1, TDK_KEYF2, TDK_KEYF3, TDK_KEYF4, TDK_KEYF5, TDK_KEYF6, TDK_KEYF7, TDK_KEYF8, TDK_KEYF9, TDK_KEYF10, TDK_KEYF11, TDK_KEYF12
These identify the function keys.

.TP
.B TDK_KEYESC, TDK_KEYTAB, TDK_KEYBSPACE, TDK_KEYSPACE, TDK_KEYENTER
These identify some UTF-8 characters.

.PP
Be aware that terminals may reserve keys for their own implementation and not support all of them. This will block you from reading them.

.SH MODIFIER KEYS

.PP
These are bitmask flags defined by the library to identify modifier keys. They are used to compose the bitmask of the \fImod\fR parameter:

.TP
.B TDK_MODCTRL
Checks if CTRL was being hold.

.TP
.B TDK_MODALT
Check if ALT was being hold.

.PP
The SHIFT modifier key does not have a flag. To detect it, you would rather have to check the character received, as SHIFT usually modifies it. For example: with it, letters are turned into uppercase.

.PP
As a design choice for simplicity and compability, this library only allows you to track modifier keys on keys identified by UTF-8 characters.

.PP
Be aware that terminals are inconsistent when reporting modifier keys. For example: CTRL + i and CTRL + j are the same as TDK_KEYTAB and TDK_KEYENTER, respectively. These situations may not allow this function to precisely give you an answer over the modifier keys used.

.SH EXAMPLES

.nf
\fB#include\fR <stdio.h>
\fB#include\fR <tdk.h>

\fBint\fR main(\fBvoid\fR)
{
	\fBint\fR key;
	\fBchar\fR mod;
	tdk_readkey(&key, &mod);
	printf(":: Key : %d.\fB\\n\fR", key);
	printf(":: CTRL: %d.\fB\\n\fR", mod & TDK_MODCTRL);
	printf(":: ALT : %d.\fB\\n\fR", mod & TDK_MODALT);
	\fBreturn\fR (0);
}
.fi

.SH SEE ALSO

.BR tdk (3),
.BR tdk_clearin (3)
